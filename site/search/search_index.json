{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"asyncio-https-proxy","text":"<p>An embeddable, asyncio-based HTTPS forward proxy server with built-in request and response interception capabilities. Designed to be integrated directly into your Python applications rather than run as a standalone service.</p> <p>It's designed to be a lightweight, flexible solution for developers needing to proxy HTTP and HTTPS traffic within their applications, with full support for SSL/TLS interception. Developer keep control over the outgoing requests and responses allowing to use custom logic for modifying, logging, blocking traffic and even custom TLS fingerprinting.</p> <p>The library is built using Python's asyncio framework, making it suitable for high-performance, asynchronous applications.</p> <p>The library manages its own Certificate Authority (CA) to dynamically generate and sign certificates for intercepted HTTPS traffic.</p> <p>It's a fundation layer for building your own proxy-based tools.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Embeddable: Integrate proxy functionality directly into your Python application</li> <li>Asyncio-native: Built with Python's asyncio for seamless integration with async applications</li> <li>HTTPS/SSL support: Full SSL/TLS interception</li> <li>Certificate generation: Dynamically generate and sign certificates for intercepted HTTPS traffic</li> <li>Request/Response interception: Modify, log, or block HTTP(S) traffic in real-time</li> <li>Lightweight: Pure Python implementation with only cryptography as a direct external dependency</li> </ul>"},{"location":"#use-cases","title":"Use Cases","text":"<ul> <li>Web scraping frameworks with request modification and custom TLS fingerprinting support</li> <li>Testing frameworks with traffic interception</li> <li>Security tools and traffic analysis</li> <li>Development tools requiring HTTP(S) proxying</li> <li>Custom cache or logging solutions</li> <li>Fault injection and network simulation</li> <li>Research and educational purposes</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Here's a simple example to get you started:</p> <pre><code>import asyncio\nimport httpx\nfrom asyncio_https_proxy import start_proxy_server, HTTPSProxyHandler, TLSStore\n\nclass BasicProxyHandler(HTTPSProxyHandler):\n    async def on_client_connected(self):\n        print(f\"Client connected: {self.request.method} {self.request.url()}\")\n\n    async def on_request_received(self):\n        # Forward the request to the target server\n        await self._forward_request()\n\n    async def _forward_request(self):\n        # Implementation details...\n        pass\n\nasync def main():\n    tls_store = TLSStore()\n    server = await start_proxy_server(\n        handler_builder=lambda: BasicProxyHandler(),\n        host=\"127.0.0.1\",\n        port=8888,\n        tls_store=tls_store,\n    )\n\n    async with server:\n        await server.serve_forever()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<p>Install the package using pip:</p> <pre><code>pip install asyncio-https-proxy\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Ready to start building with asyncio-https-proxy? Check out our Getting Started guide for detailed examples and tutorials.</p> <p>For API documentation, see the API Reference.</p>"},{"location":"custom-ca/","title":"Use a custom Certificate Authority (CA)","text":"<p>Security Warning</p> <p>When using a custom CA bundle, ensure that nobody else can access the private key of your CA certificate. If an attacker gains access to the private key, they could potentially intercept and decrypt your HTTPS traffic. This is a significant security risk, so handle the CA private key with care and trust this CA only in secure and controlled environments.</p> <p>Do not trust this CA in your operating system or browser, as it could compromise your security. Use dedicated browser instance or load the CA certificate only in specific applications where you need to intercept HTTPS traffic.</p> <p>A certificate authority (CA) is used to sign the certificates for the domains you proxy. By default your system's trusted CA bundle is used to validate the certificates of the target servers.</p> <p>To intercept HTTPS traffic, you need to create your own CA certificate and configure your system or application to trust this CA. This allows the proxy to generate and sign certificates for the target domains on-the-fly, allowing it to decrypt and inspect the HTTPS traffic.</p>"},{"location":"custom-ca/#usage-of-custom-ca-in-your-applications","title":"Usage of custom CA in your applications","text":""},{"location":"custom-ca/#curl","title":"Curl","text":"<p>To use a custom CA bundle with curl, you can use the <code>--cacert</code> option to specify the path to your CA certificate file.</p> <pre><code>curl --cacert ca_certificate.pem --proxy http://127.0.0.1:8888 https://httpbin.org/get\n</code></pre>"},{"location":"development/","title":"Development","text":"<p>This section provides information for developers who want to contribute to the project.</p>"},{"location":"development/#setting-up-the-development-environment","title":"Setting Up the Development Environment","text":"<p>You can use <code>uv</code> to set up a virtual environment for development.</p> <pre><code>uv sync --dev\n</code></pre>"},{"location":"development/#running-tests","title":"Running Tests","text":"<p>To run the test suite, use the following command:</p> <pre><code>uv run pytest tests/\n</code></pre>"},{"location":"development/#documentation","title":"Documentation","text":"<p>The documentation is built using MkDocs with the Material theme.</p> <p>To build the documentation, execute the following command:</p> <pre><code>uv run mkdocs build\n</code></pre> <p>Or to get live updates while editing the documentation:</p> <pre><code>uv run mkdocs serve\n</code></pre> <p>This will start a development server at <code>http://127.0.0.1:8000</code> with automatic reload when you make changes to the documentation files.</p>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#what-is-the-difference-with-mitmproxy","title":"What is the difference with Mitmproxy?","text":"<p>Mitmproxy is a full-featured, standalone interactive proxy server with a rich user interface and extensive features for intercepting and modifying traffic. It is designed to be run as a separate application and does not embed directly into other applications.</p> <p>Mitmproxy is a development tools it's not designed to be used for production environments.</p>"},{"location":"faq/#what-is-the-difference-with-proxypy","title":"What is the difference with proxy.py?","text":"<p>Proxy.py is a lightweight, standalone HTTP proxy server, it can be extended with plugins and can be embedded into other applications. However, it is not specifically designed for embedding. ayncio-https-proxy is built from the ground up to be an embeddable component with only asyncio support.</p>"},{"location":"faq/#can-i-use-this-in-a-production-environment","title":"Can I use this in a production environment?","text":"<p>This library is designed for embedding into applications and can be used in production.</p>"},{"location":"faq/#what-is-the-license","title":"What is the license?","text":"<p>This project is licensed under the Apache 2.0 License. See the license for details: https://www.apache.org/licenses/LICENSE-2.0</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This guide will walk you through setting up and using asyncio-https-proxy to create your own HTTPS proxy server with request/response interception capabilities.</p>"},{"location":"getting-started/#overview","title":"Overview","text":"<p>asyncio-https-proxy is an embeddable, asyncio-based HTTPS forward proxy server that allows you to intercept, modify, and analyze HTTP and HTTPS traffic. Unlike standalone proxy servers, this library is designed to be integrated directly into your Python applications.</p>"},{"location":"getting-started/#key-concepts","title":"Key Concepts","text":"<p>HTTPS Interception : The proxy can intercept HTTPS traffic by acting as a man-in-the-middle. It generates certificates on-the-fly using its own Certificate Authority (CA).</p> <p>Handler-Based Architecture : You implement a custom handler class that extends HTTPSProxyHandler to define how requests and responses are processed.</p> <p>Asyncio Native : Built using Python's asyncio framework for high-performance, non-blocking operations.</p>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<p>Python Version : Requires Python 3.13 or later.</p> <p>Dependencies : - <code>cryptography</code> - For TLS/SSL certificate generation and handling (installed automatically)</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>Basic Installation</p> <p>Install the package using pip:</p> <pre><code>pip install asyncio-https-proxy\n</code></pre>"},{"location":"getting-started/#quick-start","title":"Quick Start","text":"<p>Here's a complete working example that creates a basic HTTPS proxy server that use HTTPX to forward requests.</p> <p>Step 1: Create the Handler</p> <p>First, create a custom handler that extends HTTPSProxyHandler:</p> <pre><code>import asyncio\nimport httpx\nfrom asyncio_https_proxy import start_proxy_server, HTTPSProxyHandler, TLSStore\n\n\nclass BasicProxyHandler(HTTPSProxyHandler):\n    \"\"\"A basic proxy handler that forwards requests and logs activity.\"\"\"\n\n    async def on_client_connected(self):\n        \"\"\"Called when a client connects to the proxy.\"\"\"\n        print(f\"Client connected: {self.request.method} {self.request.url()}\")\n\n    async def on_request_received(self):\n        \"\"\"Called when a complete request has been received from the client.\"\"\"\n        # Log request headers\n        print(\"Request Headers:\")\n        for key, value in self.request.headers:\n            print(f\"  {key}: {value}\")\n\n        # Forward the request to the target server\n        await self._forward_request()\n\n    async def _forward_request(self):\n        \"\"\"Forward the request to the target server and relay the response.\"\"\"\n        try:\n            # Create HTTP client for forwarding requests\n            async with httpx.AsyncClient() as client:\n                # Forward the request with all original headers and body\n                async with client.stream(\n                    method=self.request.method,\n                    url=self.request.url(),\n                    headers=self.request.headers.to_dict(),\n                    content=self.read_request_body(),  # Stream request body\n                ) as response:\n                    print(f\"Response: {response.status_code} {response.reason_phrase}\")\n\n                    # Send response status line\n                    self.write_response(\n                        f\"HTTP/1.1 {response.status_code} {response.reason_phrase}\\\\r\\\\n\".encode()\n                    )\n\n                    # Forward response headers\n                    for key, value in response.headers.items():\n                        self.write_response(f\"{key}: {value}\\\\r\\\\n\".encode())\n                    self.write_response(b\"\\\\r\\\\n\")\n\n                    # Stream response body\n                    async for chunk in response.aiter_bytes():\n                        self.write_response(chunk)\n\n        except Exception as e:\n            print(f\"Error forwarding request: {e}\")\n            # Send error response\n            self.write_response(b\"HTTP/1.1 500 Internal Server Error\\\\r\\\\n\\\\r\\\\n\")\n            self.write_response(f\"Proxy Error: {str(e)}\".encode())\n</code></pre> <p>Step 2: Start the Proxy Server</p> <p>Create the main function to start your proxy:</p> <pre><code>async def main():\n    \"\"\"Start the HTTPS proxy server.\"\"\"\n\n    # Configuration\n    host = \"127.0.0.1\"\n    port = 8888\n\n    print(f\"Starting HTTPS proxy on {host}:{port}\")\n    print(\"\\\\nThe proxy will intercept both HTTP and HTTPS traffic.\")\n    print(\"For HTTPS, it generates certificates on-the-fly using a built-in CA.\")\n\n    # Initialize TLS store (creates CA certificate automatically)\n    tls_store = TLSStore()\n    print(f\"\\\\nGenerated CA certificate. Clients may show security warnings.\")\n    print(\"Use --insecure with curl\")\n\n    # Start the proxy server\n    server = await start_proxy_server(\n        handler_builder=lambda: BasicProxyHandler(),\n        host=host,\n        port=port,\n        tls_store=tls_store,\n    )\n\n    print(f\"\\\\nProxy server started. Test with:\")\n    print(f\"  curl --insecure --proxy http://{host}:{port} https://httpbin.org/get\")\n    print(\"\\\\nPress Ctrl+C to stop...\")\n\n    # Run the server\n    async with server:\n        try:\n            await server.serve_forever()\n        except KeyboardInterrupt:\n            print(\"\\\\nShutting down proxy server...\")\n        finally:\n            server.close()\n            await server.wait_closed()\n            print(\"Proxy server stopped.\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"getting-started/#testing-your-proxy","title":"Testing Your Proxy","text":"<p>Test HTTP Requests</p> <pre><code>curl --proxy http://127.0.0.1:8888 http://httpbin.org/get\n</code></pre> <p>Expected output shows the JSON response from httpbin.org, and your proxy will log:</p> <pre><code>Client connected: GET http://httpbin.org/get\nRequest Headers:\n  Host: httpbin.org\n  User-Agent: curl/7.68.0\n  Accept: */*\nResponse: 200 OK\n</code></pre> <p>Test HTTPS Requests</p> <pre><code>curl --insecure --proxy http://127.0.0.1:8888 https://httpbin.org/get\n</code></pre> <p>The <code>--insecure</code> flag is needed because the proxy uses a self-signed CA certificate. You should see similar output as above.</p> <p>Test with Browser</p> <p>Configure your browser to use <code>127.0.0.1:8888</code> as an HTTP proxy. You'll need to accept security warnings for HTTPS sites due to the self-signed certificates.</p>"},{"location":"getting-started/#understanding-the-handler-lifecycle","title":"Understanding the Handler Lifecycle","text":"<p>The <code>HTTPSProxyHandler</code> has a well-defined lifecycle:</p> <ol> <li>Client Connection: When a client connects, <code>on_client_connected()</code> is called</li> <li>Request Parsing: The server parses the HTTP request and assigns it to <code>self.request</code></li> <li>Request Processing: <code>on_request_received()</code> is called with the complete request</li> <li>Response Generation: Your handler processes the request and writes the response</li> <li>Connection Cleanup: The connection is automatically cleaned up</li> </ol> <p>See the HTTPSProxyHandler for more details on available methods and attributes. And HTTPRequest for request structure.</p>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>Now that you have a working proxy, you can:</p> <ul> <li>Implement custom request/response modification logic</li> <li>Add authentication and access control</li> <li>Integrate with logging and monitoring systems  </li> <li>Build web scraping or testing tools</li> <li>Create security analysis tools</li> </ul> <p>For more advanced usage, see the API Reference.</p>"},{"location":"reference/","title":"API Reference","text":"<p>This section contains the complete API documentation for asyncio-https-proxy.</p>"},{"location":"reference/#main-function","title":"Main Function","text":""},{"location":"reference/#asyncio_https_proxy.start_proxy_server","title":"<code>start_proxy_server(handler_builder, host, port, tls_store)</code>  <code>async</code>","text":"<p>Start the proxy server.</p> <p>Parameters:</p> Name Type Description Default <code>handler_builder</code> <code>Callable[[], HTTPSProxyHandler]</code> <p>A callable that returns a new instance of HTTPSProxyHandler.</p> required <code>host</code> <code>str</code> <p>The host to bind the server to.</p> required <code>port</code> <code>int</code> <p>The port to bind the server to.</p> required"},{"location":"reference/#classes","title":"Classes","text":"<ul> <li>HTTPSProxyHandler - Base handler class for processing requests</li> <li>HTTPRequest - HTTP request representation</li> <li>HTTPHeader - HTTP header collection</li> <li>TLSStore - TLS certificate management</li> </ul>"},{"location":"reference/http_header/","title":"HTTPHeader","text":""},{"location":"reference/http_header/#asyncio_https_proxy.HTTPHeader","title":"<code>HTTPHeader(raw_headers)</code>","text":"<p>Represents HTTP headers, preserving order and allowing duplicates.</p>"},{"location":"reference/http_header/#asyncio_https_proxy.HTTPHeader.first","title":"<code>first(key)</code>","text":"<p>Get the first occurrence of a header by key (case-insensitive).</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Header key to search for</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>The header value or None if not found</p>"},{"location":"reference/http_header/#asyncio_https_proxy.HTTPHeader.to_raw","title":"<code>to_raw()</code>","text":"<p>Convert headers back to raw bytes.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>Raw headers as bytes</p>"},{"location":"reference/http_header/#asyncio_https_proxy.HTTPHeader.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert headers to a dictionary. If multiple headers have the same key, only the last one is kept.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Headers as a dictionary</p>"},{"location":"reference/http_request/","title":"HTTPRequest","text":""},{"location":"reference/http_request/#asyncio_https_proxy.HTTPRequest","title":"<code>HTTPRequest</code>","text":"<p>Represents an HTTP request with methods to parse the request line and headers.</p>"},{"location":"reference/http_request/#asyncio_https_proxy.HTTPRequest.host","title":"<code>host</code>  <code>instance-attribute</code>","text":"<p>The target host of the HTTP request.</p>"},{"location":"reference/http_request/#asyncio_https_proxy.HTTPRequest.port","title":"<code>port</code>  <code>instance-attribute</code>","text":"<p>The target port of the HTTP request.</p>"},{"location":"reference/http_request/#asyncio_https_proxy.HTTPRequest.scheme","title":"<code>scheme</code>  <code>instance-attribute</code>","text":"<p>The scheme of the HTTP request, either 'http' or 'https'.</p>"},{"location":"reference/http_request/#asyncio_https_proxy.HTTPRequest.version","title":"<code>version</code>  <code>instance-attribute</code>","text":"<p>The HTTP version, e.g. 'HTTP/1.1'.</p>"},{"location":"reference/http_request/#asyncio_https_proxy.HTTPRequest.method","title":"<code>method</code>  <code>instance-attribute</code>","text":"<p>The HTTP method, e.g. 'GET', 'POST', 'CONNECT'.</p>"},{"location":"reference/http_request/#asyncio_https_proxy.HTTPRequest.path","title":"<code>path</code>  <code>instance-attribute</code>","text":"<p>The path of the HTTP request, e.g. '/'.</p>"},{"location":"reference/http_request/#asyncio_https_proxy.HTTPRequest.headers","title":"<code>headers</code>  <code>instance-attribute</code>","text":"<p>The HTTP headers as an HTTPHeader object.</p>"},{"location":"reference/http_request/#asyncio_https_proxy.HTTPRequest.parse_request_line","title":"<code>parse_request_line(request_line)</code>","text":"<p>Parse the request line of an HTTP request.</p> <p>Parameters:</p> Name Type Description Default <code>request_line</code> <code>bytes</code> <p>The request line as bytes, e.g. b\"GET / HTTP/1.1\"</p> required"},{"location":"reference/http_request/#asyncio_https_proxy.HTTPRequest.parse_headers","title":"<code>parse_headers(raw_headers)</code>","text":"<p>Parse raw HTTP headers from bytes.</p> <p>Parameters:</p> Name Type Description Default <code>raw_headers</code> <code>bytes</code> <p>Raw headers as bytes</p> required"},{"location":"reference/http_request/#asyncio_https_proxy.HTTPRequest.parse_host","title":"<code>parse_host()</code>","text":"<p>Parse the Host header to set the host and port attributes.</p>"},{"location":"reference/http_request/#asyncio_https_proxy.HTTPRequest.url","title":"<code>url()</code>","text":"<p>Construct the full URL of the HTTP request.</p> <p>Returns:</p> Type Description <code>str</code> <p>The full URL as a string</p>"},{"location":"reference/https_proxy_handler/","title":"HTTPSProxyHandler","text":""},{"location":"reference/https_proxy_handler/#asyncio_https_proxy.HTTPSProxyHandler","title":"<code>HTTPSProxyHandler</code>","text":"<p>An instance of a connection from a client to the HTTPS proxy server</p> <p>Each new client connection will create a new instance of this class.</p>"},{"location":"reference/https_proxy_handler/#asyncio_https_proxy.HTTPSProxyHandler.client_reader","title":"<code>client_reader</code>  <code>instance-attribute</code>","text":"<p>StreamReader for reading data from the client</p>"},{"location":"reference/https_proxy_handler/#asyncio_https_proxy.HTTPSProxyHandler.client_writer","title":"<code>client_writer</code>  <code>instance-attribute</code>","text":"<p>StreamWriter for writing data to the client</p>"},{"location":"reference/https_proxy_handler/#asyncio_https_proxy.HTTPSProxyHandler.request","title":"<code>request</code>  <code>instance-attribute</code>","text":"<p>The parsed HTTP request from the client (set by the server)</p>"},{"location":"reference/https_proxy_handler/#asyncio_https_proxy.HTTPSProxyHandler.on_client_connected","title":"<code>on_client_connected()</code>  <code>async</code>","text":"<p>Called when a client has connected to the proxy and sent a valid request.</p> <p>Override this method to implement custom behavior.</p>"},{"location":"reference/https_proxy_handler/#asyncio_https_proxy.HTTPSProxyHandler.on_request_received","title":"<code>on_request_received()</code>  <code>async</code>","text":"<p>Called when a complete request has been received from the client.</p> <p>Override this method to implement custom behavior.</p>"},{"location":"reference/https_proxy_handler/#asyncio_https_proxy.HTTPSProxyHandler.read_request_body","title":"<code>read_request_body()</code>  <code>async</code>","text":"<p>Read the request body from the client. This is an async generator that yields chunks of the request body.</p> <p>Yields:</p> Type Description <code>AsyncIterator[bytes]</code> <p>Chunks of the request body as bytes.</p>"},{"location":"reference/https_proxy_handler/#asyncio_https_proxy.HTTPSProxyHandler.write_response","title":"<code>write_response(content)</code>","text":"<p>Write response data to the client. Until <code>flush_response()</code> is called, the data may be buffered.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>bytes</code> <p>The content to send to the client.</p> required"},{"location":"reference/https_proxy_handler/#asyncio_https_proxy.HTTPSProxyHandler.flush_response","title":"<code>flush_response()</code>  <code>async</code>","text":"<p>Flush the response data to the client.</p>"},{"location":"reference/tls_store/","title":"TLSStore","text":""},{"location":"reference/tls_store/#asyncio_https_proxy.TLSStore","title":"<code>TLSStore()</code>","text":"<p>A simple in-memory TLS store that generates a CA and signs certificates for domains on the fly.</p>"},{"location":"reference/tls_store/#asyncio_https_proxy.TLSStore.get_ca_pem","title":"<code>get_ca_pem()</code>","text":"<p>Get the CA PEM certificate.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>The CA certificate in PEM format.</p>"},{"location":"reference/tls_store/#asyncio_https_proxy.TLSStore.get_ssl_context","title":"<code>get_ssl_context(domain)</code>","text":"<p>Get a new SSL context for a given domain. If no certificate is found, generate a new one.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>str</code> <p>The domain to get the certificate for.</p> required"}]}
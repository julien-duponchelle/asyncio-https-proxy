Getting Started
===============

This guide will walk you through setting up and using asyncio-https-proxy to create your own HTTPS proxy server with request/response interception capabilities.

.. toctree::
   :maxdepth: 2

Overview
--------

asyncio-https-proxy is an embeddable, asyncio-based HTTPS forward proxy server that allows you to intercept, modify, and analyze HTTP and HTTPS traffic. Unlike standalone proxy servers, this library is designed to be integrated directly into your Python applications.

Key Concepts
~~~~~~~~~~~~

**HTTPS Interception**
  The proxy can intercept HTTPS traffic by acting as a man-in-the-middle. It generates certificates on-the-fly using its own Certificate Authority (CA).

**Handler-Based Architecture**
  You implement a custom handler class that extends :doc:`api/https_proxy_handler` to define how requests and responses are processed.

**Asyncio Native**
  Built using Python's asyncio framework for high-performance, non-blocking operations.

Prerequisites
-------------

**Python Version**
  Requires Python 3.13 or later.

**Dependencies**
  - ``cryptography`` - For TLS/SSL certificate generation and handling (installed automatically)

Installation
------------

**Basic Installation**

Install the package using pip:

.. code-block:: console

   $ pip install asyncio-https-proxy


Quick Start
-----------

Here's a complete working example that creates a basic HTTPS proxy server that use HTTPX to forward requests.

**Step 1: Create the Handler**

First, create a custom handler that extends :doc:`api/https_proxy_handler`:

.. code-block:: python

   import asyncio
   import httpx
   from asyncio_https_proxy import start_proxy_server, HTTPSProxyHandler, TLSStore


   class BasicProxyHandler(HTTPSProxyHandler):
       """A basic proxy handler that forwards requests and logs activity."""
       
       async def on_client_connected(self):
           """Called when a client connects to the proxy."""
           print(f"Client connected: {self.request.method} {self.request.url()}")

       async def on_request_received(self):
           """Called when a complete request has been received from the client."""
           # Log request headers
           print("Request Headers:")
           for key, value in self.request.headers:
               print(f"  {key}: {value}")
           
           # Forward the request to the target server
           await self._forward_request()
       
       async def _forward_request(self):
           """Forward the request to the target server and relay the response."""
           try:
               # Create HTTP client for forwarding requests
               async with httpx.AsyncClient() as client:
                   # Forward the request with all original headers and body
                   async with client.stream(
                       method=self.request.method,
                       url=self.request.url(),
                       headers=self.request.headers.to_dict(),
                       content=self.read_request_body(),  # Stream request body
                   ) as response:
                       print(f"Response: {response.status_code} {response.reason_phrase}")
                       
                       # Send response status line
                       self.write_response(
                           f"HTTP/1.1 {response.status_code} {response.reason_phrase}\\r\\n".encode()
                       )
                       
                       # Forward response headers
                       for key, value in response.headers.items():
                           self.write_response(f"{key}: {value}\\r\\n".encode())
                       self.write_response(b"\\r\\n")
                       
                       # Stream response body
                       async for chunk in response.aiter_bytes():
                           self.write_response(chunk)
                           
           except Exception as e:
               print(f"Error forwarding request: {e}")
               # Send error response
               self.write_response(b"HTTP/1.1 500 Internal Server Error\\r\\n\\r\\n")
               self.write_response(f"Proxy Error: {str(e)}".encode())

**Step 2: Start the Proxy Server**

Create the main function to start your proxy:

.. code-block:: python

   async def main():
       """Start the HTTPS proxy server."""
       
       # Configuration
       host = "127.0.0.1"
       port = 8888
       
       print(f"Starting HTTPS proxy on {host}:{port}")
       print("\\nThe proxy will intercept both HTTP and HTTPS traffic.")
       print("For HTTPS, it generates certificates on-the-fly using a built-in CA.")
       
       # Initialize TLS store - this automatically generates a new CA certificate
       # The CA (Certificate Authority) is used to sign certificates for intercepted domains
       tls_store = TLSStore()
       print(f"\\nGenerated new CA certificate. Clients may show security warnings.")
       print("Use --insecure with curl or install the CA certificate in your trust store.")
       
       # Start the proxy server
       server = await start_proxy_server(
           handler_builder=lambda: BasicProxyHandler(),
           host=host,
           port=port,
           tls_store=tls_store,
       )
       
       print(f"\\nProxy server started. Test with:")
       print(f"  curl --insecure --proxy http://{host}:{port} https://httpbin.org/get")
       print("\\nPress Ctrl+C to stop...")
       
       # Run the server
       async with server:
           try:
               await server.serve_forever()
           except KeyboardInterrupt:
               print("\\nShutting down proxy server...")
           finally:
               server.close()
               await server.wait_closed()
               print("Proxy server stopped.")


   if __name__ == "__main__":
       asyncio.run(main())

Testing Your Proxy
-------------------

**Test HTTP Requests**

.. code-block:: console

   $ curl --proxy http://127.0.0.1:8888 http://httpbin.org/get

Expected output shows the JSON response from httpbin.org, and your proxy will log:

.. code-block:: text

   Client connected: GET http://httpbin.org/get
   Request Headers:
     Host: httpbin.org
     User-Agent: curl/7.68.0
     Accept: */*
   Response: 200 OK

**Test HTTPS Requests**

.. code-block:: console

   $ curl --insecure --proxy http://127.0.0.1:8888 https://httpbin.org/get

The ``--insecure`` flag is needed because the proxy uses a self-signed CA certificate. You should see similar output as above.

**Test with Browser**

Configure your browser to use ``127.0.0.1:8888`` as an HTTP proxy. You'll need to accept security warnings for HTTPS sites due to the self-signed certificates.

Understanding the Handler Lifecycle
------------------------------------

The ``HTTPSProxyHandler`` has a well-defined lifecycle:

1. **Client Connection**: When a client connects, ``on_client_connected()`` is called
2. **Request Parsing**: The server parses the HTTP request and assigns it to ``self.request``
3. **Request Processing**: ``on_request_received()`` is called with the complete request
4. **Response Generation**: Your handler processes the request and writes the response
5. **Connection Cleanup**: The connection is automatically cleaned up


See the :doc:`api/https_proxy_handler` for more details on available methods and attributes.
And :doc:`api/http_request` for request structure.

Advanced Configuration
----------------------

**CA Certificate Management**

By default, ``TLSStore()`` automatically generates a new Certificate Authority (CA) certificate and private key each time it's initialized. This CA is used to sign certificates for domains you intercept.

**Using an Existing CA Certificate**

If you have an existing CA certificate and key, you can provide them to avoid generating new ones:

.. code-block:: python

   # Load your existing CA certificate and key from files
   with open("my_ca.crt", "rb") as f:
       ca_cert_pem = f.read()
   
   with open("my_ca.key", "rb") as f:
       ca_key_pem = f.read()
   
   # Initialize TLS store with existing CA
   tls_store = TLSStore(ca_cert_pem=ca_cert_pem, ca_key_pem=ca_key_pem)

**Saving Generated CA for Reuse**

If you want to reuse the same CA across multiple runs (to avoid certificate warnings):

.. code-block:: python

   # Generate CA once and save it
   tls_store = TLSStore()  # Generates new CA
   
   # Save CA certificate and key for later reuse
   with open("generated_ca.crt", "wb") as f:
       f.write(tls_store.get_ca_pem())
   
   with open("generated_ca.key", "wb") as f:
       f.write(tls_store.get_ca_key_pem())
   
   print("CA certificate and key saved. Install generated_ca.crt in your trust store.")

**Installing CA Certificate in Trust Store**

To avoid ``--insecure`` warnings, install the CA certificate in your system's trust store:

.. code-block:: python

   # Extract the CA certificate for installation
   tls_store = TLSStore()
   ca_pem = tls_store.get_ca_pem()
   
   # Save to file for installation
   with open("proxy_ca.crt", "wb") as f:
       f.write(ca_pem)

Then add ``proxy_ca.crt`` to your system's certificate trust store:

- **Linux**: Copy to ``/usr/local/share/ca-certificates/`` and run ``sudo update-ca-certificates``
- **macOS**: Use Keychain Access to add the certificate to System keychain
- **Windows**: Use ``certmgr.msc`` to add to Trusted Root Certification Authorities

Next Steps
----------

Now that you have a working proxy, you can:

- Implement custom request/response modification logic
- Add authentication and access control
- Integrate with logging and monitoring systems  
- Build web scraping or testing tools
- Create security analysis tools

For more advanced usage, see the :doc:`api_reference`.